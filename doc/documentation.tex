\documentclass[11pt]{article}

\usepackage{hyperref}
\usepackage{xspace}
\usepackage{setspace}
\usepackage{paralist}
\usepackage{amsmath}

\setlength{
\topmargin}{-.5in} \setlength{
\textheight}{9in} \setlength{
\oddsidemargin}{.125in} \setlength{
\textwidth}{6.25in}

\begin{document}

\newcommand{
\sectionLabel}[2] {
\section{#1} \label{sec:#2} }
\newcommand{
\subsectionLabel}[2] {
\subsection{#1} \label{sub:#2} }
\newcommand{\fixedWidthInList}[4] {
\item[\texttt{#1} \textnormal{#2} \url{#3}] \hfill \\
#4 }
\newcommand{\optionListItem}[2] {\item[\optionFlag{#1}] #2}
\newcommand{\optionFlag}[1] {\ttt{-#1/-\MakeUppercase{#1}}}
\newcommand{\ttt}[1]{{\tt #1}\xspace}
\newcommand{\hermes}{\ttt{hermes}}
\newcommand{\multiParam}{\ttt{multi\_param}}
\newcommand{\fft}{\ttt{FFTbor2D}}
\newcommand{\rnamfpt}{\ttt{RNAmfpt}}
\newcommand{\rnaeq}{\ttt{RNAeq}}
\newcommand{\fftmfpt}{\ttt{FFTmfpt}}
\newcommand{\ffteq}{\ttt{FFTeq}}
\newcommand{\rateeq}{\ttt{RateEq}}
\newcommand{\s}{$s$\xspace}
\newcommand{\A}{$A$\xspace}
\newcommand{\B}{$B$\xspace}
\newcommand{\req}{{\em (requried)}\xspace}
\newcommand{\kcalMol}{{\footnotesize $\dfrac{\text{kcal}}{\text{mol}}$}\xspace}
\newcommand{\rt}{\text{RT}}
\newcommand{\logt}{\ensuremath{\log_{10} t}}
\newcommand{\logtime}{$\log_{10}$-time\xspace}
\newcommand{\tStart}{\ensuremath{t_{\text{start}}}\xspace}
\newcommand{\tStop}{\ensuremath{t_{\text{stop}}}\xspace}

\title{Hermes Documentation}
\author{Evan Senter}

\maketitle \clearpage
\tableofcontents \clearpage

\sectionLabel{Introduction}{intro}

This documentation aims to outline the basic dependencies, installation, and usage of the Hermes RNA software suite, as well as provide extended commentary on the flags and options available to code. Particular attention is payed to the invocation style of extension programs (using \multiParam) to dispatch flags to the appropriate submodules. To get started as quickly as possible, see the quickstart one-liner in \ref{sub:quickstart}. Should you still have questions, you can reach the main author of the source code at \href{mailto:evansenter@gmail.com}{evansenter@gmail.com}.

\sectionLabel{Installation}{install}

\subsectionLabel{Quick Start}{quickstart}

From the root directory of Hermes, execute the following command:

{\tt cd build \&\& cmake .. \&\& make}

If you encounter errors in configuring or compiling the software, we recommend checking section \ref{sub:faq} for common troubleshooting solutions.

\subsectionLabel{Dependencies}{dependencies}
\begin{description}
  \fixedWidthInList{cmake}{($\geq$ 2.6-patch 4, tested through 3.0.0)}{http://www.cmake.org/}{ \\
  CMake is used as the build system for Hermes.}
  \fixedWidthInList{\textnormal{GNU99 compiler:}}{}{}{ \\
  Most C compilers should support the \ttt{-std=gnu99} flag, which is required for GNU library extensions, particularly \ttt{unistd.h}}
  \fixedWidthInList{\textnormal{C++11 compiler:}}{}{}{ \\
  C++11 support (included in \ttt{g++} $\geq$ 4.7) is necessary for proper struct initialization in \fft.}
  \fixedWidthInList{\textnormal{OpenMP support}}{}{http://openmp.org/wp/}{ \\
  OpenMP support comes by default in most modern compilers, and is required for loop-optimization in \fft.}
  \fixedWidthInList{LAPACK}{($\geq$ 3.4.2)}{http://www.netlib.org/lapack/}{ \\
  Various LAPACK routines are used in \rnamfpt to compute the inverse, or pseudoinverse, of a transition probability matrix. LAPACK comes with in implicit dependency on having a valid Fortran compiler which we check for, however this is only to ensure proper linking of LAPACK libraries.}
  \fixedWidthInList{GSL}{($\geq$ 1.15, tested through 1.16)}{http://www.gnu.org/software/gsl/}{ \\
  GSL is required to compute the eigendecomposition of a (possibly) non-symmetric transition rate matrix for \rnaeq.}
  \fixedWidthInList{FFTW3}{($\geq$ 3.3.4)}{http://www.fftw.org/}{ \\
  FFTW3 (\cite{fftwThreePaper}) functions are used to compute the inverse discrete Fourier transform in \fft.}
  \fixedWidthInList{libRNA.a}{($\geq$ 2.0.7, tested through 2.1.7)}{http://www.tbi.univie.ac.at/RNA/}{ \\
  Various ViennaRNA (\cite{viennaTwoPaper}) functions and data structures are leveraged for homogenous energy model support, as well as \ttt{fold\_par}, \ttt{pf\_fold\_par}, and \ttt{subopt\_par}. We additionally make use of ViennaRNA functions to compute the necessary polynomial size for \fft, determined in the following fashion. Parameters $K$ (resp. $L$) are defined to be the sum of the number of base pairs in reference structure $A$ (resp. reference structure $B$) plus the number of base pairs in the maximum matching (Nussinov) structure which contains no base pair of $A$ (resp. $B$).}
\end{description}

\subsectionLabel{Compilation}{compile}
\begin{description}
  \item[{\tt cd build \&\& cmake ..}] \hfill \\
  First, ensure that your system has the dependencies outlined above (the presence of CMake can be verified with \ttt{cmake --version}). While not required, is widely considered {\em best practice} to perform an out-of-source build, where the compilation of the code happens in a separate directory from the location of the source itself. To this end, \hermes provides an empty \ttt{build} directory that can be used for compiling the code. From \ttt{hermes/build} execute \ttt{cmake} with the path to \ttt{hermes/CMakeLists.txt} (\ttt{..}) provided as argument.
  \item[{\tt make}] \hfill \\
  Compiles the code, and generates binary executables for \fft, \rnamfpt, \rnaeq, \fftmfpt, \ffteq, and \rateeq. Additionally generates both static and shared libraries for \fft, \rnamfpt, and \rnaeq. The output directory for binaries is \ttt{hermes/bin} and output directory for libraries is \ttt{hermes/lib}.
  \item[\ttt{make install} \textnormal{(optional)}] \hfill \\
  Installs the executables built with \ttt{make} to \ttt{\$DESTDIR/bin} and copies libraries / archives to \ttt{\$DESTDIR/lib} (on *nix systems, \ttt{\$DESTDIR} defaults to \ttt{/usr/local}).
\end{description}

\subsectionLabel{Troubleshooting}{faq}

While we have done the utmost to try and ensure that CMake is able to infer locations of third-party libraries and add compiler-appropriate flags in an automated fashion, due to the diversity of build environments possible, it is possible that you will need to specify additional command-line flags to \ttt{cmake} when generating the Makefiles in order to successfully build Hermes. The following are five useful flags for CMake, and a brief explanation of when they may need to be employed:
\begin{itemize}
  \item The default compiler I'd like to use for C code is installed in a non-standard location, or not the globally default C compiler.
  \begin{description}
    \item[CMAKE\_C\_COMPILER] \hfill \\
    i.e. {\tt cmake -DCMAKE\_C\_COMPILER=/path/to/c/compiler ..} \hfill \\
    \begin{spacing}
      {.5}
    \end{spacing}
    This variable sets the path to the compiler to use for configuration and subsequent compilation via \ttt{make}. This is the compiler that will be used by CMake to test for the presence of various flags, i.e. \ttt{-O3} and \ttt{-Wall}.
  \end{description}

  \item The default compiler I'd like to use for C++ code is installed in a non-standard location, or not the globally default C++ compiler.
  \begin{description}
    \item[CMAKE\_CXX\_COMPILER] \hfill \\
    i.e. {\tt cmake -DCMAKE\_CXX\_COMPILER=/path/to/cxx/compiler ..} \hfill \\
    \begin{spacing}
      {.5}
    \end{spacing}
    Same as above.
  \end{description}

  \item I'm getting a compile-time error indicating undefined symbols for \ttt{\_get\_iindx}, \\
  \ttt{\_maximumMatchingConstraint} or something similar.
  \begin{description}
    \item[CMAKE\_LIBRARY\_PATH] \hfill \\
    i.e. {\tt cmake -DCMAKE\_LIBRARY\_PATH=/dir/for/libRNA-2.0.7+/ ..} \hfill \\
    \begin{spacing}
      {.5}
    \end{spacing}
    These are \ttt{libRNA.a} symbols specific to the $2.0+$ release of ViennaRNA. In all cases identified thus far, this error means that the version of \ttt{libRNA.a} found by CMake is not out of date, and can be resolved by explicitly providing the library path to a $2.0+$ ViennaRNA static library using the \ttt{CMAKE\_LIBRARY\_PATH} flag.
  \end{description}

  \item Libraries required by Hermes are not installed in a location visible by the linker (in LD\_LIBRARY\_PATH), and CMake is unable to validate their existence.
  \begin{description}
    \item[CMAKE\_LIBRARY\_PATH] \hfill \\
    i.e. {\tt cmake -DCMAKE\_LIBRARY\_PATH="/more/libraries;/even/more/libraries" ..} \hfill \\
    In the case when libraries required by Hermes are not visible to CMake, or the global library is an out-of-date version, it is possible to provide hints to the build tool for additional directories to search. Directories specified by the CMAKE\_LIBRARY\_PATH flag will be prepended onto the linker search path, and thus override global matches (handling the case where default libraries aren't sufficiently up to date). When desiring to provide multiple locations to search for libraries, CMake uses the semicolon (;) character as a separator and the entire string should be quoted to escape the shell environment.
  \end{description}

  \item Headers required by Hermes are not installed in a location visible by the compiler (in CPATH or a derivative), and as a result I'm seeing \ttt{undefined reference to} errors.
  \begin{description}
    \item[CMAKE\_INCLUDE\_PATH] \hfill \\
    i.e. {\tt cmake -DCMAKE\_INCLUDE\_PATH="/more/includes;/even/more/includes" ..} \hfill \\
    \begin{spacing}
      {.5}
    \end{spacing}
    It is generally likely that the CMAKE\_LIBRARY\_PATH and CMAKE\_INCLUDE\_PATH will both be necessary, when either one is required. This flag operates in a fashion identical to CMAKE\_LIBRARY\_PATH described above, and uses the same syntax. Alternatively a user can update their \ttt{CPATH} environment variable, but this may have unpredictable results when headers are found, but out of date.
  \end{description}

  \item I don't have permissions to \ttt{make install} to the default location (generally \ttt{/usr/local} for *nix) on my system.
  \begin{description}
    \item[CMAKE\_INSTALL\_PREFIX] \hfill \\
    i.e. {\tt cmake -DCMAKE\_INSTALL\_PREFIX=/make/install/path/prefix ..} \hfill \\
    \begin{spacing}
      {.5}
    \end{spacing}
    This variable sets the destination directory of the \ttt{make install} command. Binaries will be placed in the \ttt{bin} subdirectory and libraries will be placed in the \ttt{lib} subdirectory. This is analogous to \ttt{./configure --prefix=/make/install/path/prefix} in Autotools and can also be achieved by setting the \ttt{DESTDIR} environment variable.
  \end{description}
\end{itemize}

\sectionLabel{Software Organization}{organization}

\subsectionLabel{General Principles}{principles}

The Hermes code is organized into two major directories, \ttt{hermes/src} and \ttt{hermes/ext}. The conceptual difference between these two directories is that \ttt{hermes/src} code (\fft, \rnamfpt, \rnaeq) are all stand-alone pieces of software which achieve specific goals (computing energy grids, hitting time, and equilibrium time respectively). Alternatively, code residing in \ttt{hermes/ext} aims to leverage general concepts across the Hermes package to provide a means to ask even more specific questions. In example, \fft allows an investigator to compute the 2D energy grid correspondent to an input RNA sequence $s$ and two structures $A, B$. \rnaeq can estimate the population occupancy of $A, B$ for $s$ by either sampling suboptimal structures or exhaustive structural enumeration, but these approaches aren't tractable for non-trivial RNAs.

\ffteq, located in \ttt{hermes/ext/population\_from\_fftbor2d} uses functions from \\
\ttt{libfftbor\_static.a} (derived from \fft) to compute the energy landscape and functions from \ttt{librnaeq\_static.a} (derived from \rnaeq) to estimate population occupancy for $s, A, B$ without requiring an investigator to copy pieces of individual packages to achieve their goals, instead using the static libraries automatically produced for all \ttt{hermes/src} software, shared headers made available in \ttt{hermes/h} and \ttt{libmulti\_param.a} (from \ttt{hermes/src/multi\_param}) to dispatch command-line arguments to the appropriate underlying function. The result? The entirety of \ffteq is 67 lines of C++ code, and uses native binary data structures the entire way through; there is no command-line funneling of \fft into \rnaeq.

\subsectionLabel{multi\_param Overview}{mpoverview}

All of \fft, \rnamfpt, and \rnaeq present a wide selection of command-line arguments to meet the diverse demands of end users. When we moved on to developing {\em extension} software between these three programs, there were a number of requirements that we came up with to make both implementing and using these programs as easy as possible. We decided that
\begin{inparaenum}
  [\itshape a\upshape)]
  \item the developer should not have to reimplement command-line parsing for extensions
  \item all existing flags for underlying libraries (i.e. \fft, \rnamfpt, \rnaeq) would be supported, and
  \item flags would be namespaced to have deterministic targets.
\end{inparaenum}

To achieve these goals, the library \multiParam was developed. This library simply takes a collection of command line arguments and re-dispatches them to the appropriate underlying library. Given a set of command-line flags such as \ttt{--all-v --fftbor2d-i GGGAAACCC --fftbor2d-j `.........' --fftbor2d-k `(((...)))' --mfpt-x --mfpt-h}, the code ensures that \fft is passed \ttt{-v -i GGGAAACCC -j `.........' -k `(((...)))'} as options in \ttt{argv} and \rnamfpt is passed \ttt{-v -x -h} as options in \ttt{argv}.

\subsectionLabel{multi\_param Details}{mpdetails}

An example from \ttt{hermes/ext/mfpt\_from\_fftbor2d/mfpt\_from\_fftbor2d.cpp}:
\begin{verbatim}
PARAM_CONTAINER* params;
FFTBOR2D_PARAMS fftbor2d_params;

/* ...omitted for clarity... */

char* subparams[] = { "fftbor2d", "mfpt" };
params = split_args(argc, argv, subparams, 2);

fftbor2d_params = init_fftbor2d_params();
parse_fftbor2d_args(
  fftbor2d_params,
  params[0].argc,
  params[0].argv,
  &mfpt_from_fftbor2d_usage
);
\end{verbatim}

The way this code works is by first declaring which packages can be used by the extensions, out of \ttt{fftbor2d}, \ttt{mfpt}, or \ttt{population}. In the snippet above the selection is saved in the variable \ttt{subparams}. All of the \fft, \rnamfpt, and \rnaeq libraries have \ttt{init\_*\_params} functions available, which return an object with the default parameters for that package. They also all have \ttt{parse\_*\_args} functions, which take three arguments,
\begin{inparaenum}
  [\itshape 1\upshape)]
  \item a pointer to the parameters object
  \item \ttt{argc}, and
  \item \ttt{argv}
\end{inparaenum}
.

\ttt{split\_args} takes the prefixed command-line arguments (see the example in \ref{sub:mpoverview}) and bins them by their prefix, with the special \ttt{--all} prefix being supplied to all declared subparams. The prefixes are then removed and the grouped arguments are returned from the function in a \ttt{PARAM\_CONTAINER} array, with the same order as the subparams were passed to the function. It is then trivial to call the \ttt{parse\_*\_args} functions with the corresponding subarrays from \ttt{PARAM\_CONTAINER} to get a final parameters object.

Leveraging the example from \ref{sub:mpoverview} a final time, the variable \ttt{params} would look as follows after invoking \ttt{split\_args}:
\begin{verbatim}
[
  {
    argv: ['-v', '-i', 'GGGAAACCC', '-j', '.........', '-k', '(((...)))'],
    argc: 7
  }, {
    argv: ['-v', '-x', '-h'],
    argc: 3
  }
]
\end{verbatim}

\sectionLabel{Core Programs}{coreprogs}

\subsectionLabel{{\tt FFTbor2D}}{fft}

\subsubsection{Applications} \label{subsub:fftborapp}

\fft (\cite{fftTwoPaper}) computes the 2D energy landscape of an arbitrary but fixed sequence \s, parameterized by base pair distance from input structures \A and \B.

\subsubsection{Example Usage} \label{subsub:fftborex}

\begin{verbatim}
FFTbor2D -m -i GGGAAACCC -j '.........' -k '(((...)))' -e ./misc/rna_turner2004.par

+0.00000000  +0.00000000  +0.00000000  +0.10047371  +0.00000000  +0.00000000  ...
+0.00000000  +0.00000000  +0.00019384  +0.00000000  +0.00181492  +0.00000000  ...
+0.00000000  +0.02666435  +0.00000000  +0.00036362  +0.00000000  +0.16642614  ...
+0.70406341  +0.00000000  +0.00000000  +0.00000000  +0.00000000  +0.00000000  ...
+0.00000000  +0.00000000  +0.00000000  +0.00000000  +0.00000000  +0.00000000  ...
+0.00000000  +0.00000000  +0.00000000  +0.00000000  +0.00000000  +0.00000000  ...
+0.00000000  +0.00000000  +0.00000000  +0.00000000  +0.00000000  +0.00000000  ...
\end{verbatim}

In the above example, position $(0, 0)$ is located in the upper-left of the output matrix, and base pair distance from \A (resp. \B) moves along the rows (resp. columns). This can be verified using the \optionFlag{c} flag for CSV output instead of matrix formatting (using \optionFlag{m}):

\begin{verbatim}
FFTbor2D -c -i GGGAAACCC -j '.........' -k '(((...)))' -e ./misc/rna_turner2004.par

0,3,+0.10047371
1,2,+0.00019384
1,4,+0.00181492
2,1,+0.02666435
2,3,+0.00036362
2,5,+0.16642614
3,0,+0.70406341
\end{verbatim}

\subsubsection{Options} \label{subsub:fftboropt}

\begin{itemize}
  \optionListItem{i}{\req The RNA sequence \s to be used by \fft.}
  \optionListItem{j}{\req The first structure \A to be used by \fft. Any base pairs in \A incompatible with \s (i.e. not a Watson-Crick or GU wobble) are ignored by \fft.}
  \optionListItem{k}{\req The second structure \B to be used by \fft. The same restrictions apply as with \optionFlag{j}.}
  \optionListItem{t}{The temperature at which the energy landscape is computed. The provided value is used both in computing Boltzmann factors ($\beta = -1/\rt$) and for energy table lookups. The default is $37^{\circ}$C.}
  \optionListItem{e}{The energy file to be used by \fft, in the Vienna 2.0 format. The default is \ttt{rna\_turner2004.par} located in the same directory as the \fft executable.}
  \optionListItem{p}{The precision $m$ of the probabilities output by \fft, in base 2 format. The default is system specific (you can call \fft with no parameters to see the precision range available on your platform), and using $0$ disables any precision control---not recommended. The default is 27, which corresponds to 8 decimal places of precision.}
  \optionListItem{b}{Enables the output of performance related benchmarking for all major subroutines in \fft.}
  \item[Output formatting flags (mutually exclusive):] \hfill
    \begin{itemize}
      \item[] The default format is a verbose version of \optionFlag{s} which also includes the user-input \s, \A, \B, and column headers.
      \optionListItem{c}{CSV-formatted output, where only non-zero positions are emitted. The first (resp. second) column corresponds to base pair distance from \A (resp. \B), and the final column is the Boltzmann probability ($p(Z_{k, l}/Z)$) for that position.}
      \optionListItem{m}{Output formatted as a matrix, where $(0, 0)$ is in the lop-left and base pair distance from \A (resp. \B) moves along the rows (resp. columns).}
      \optionListItem{s}{Output formatted in the same fashion as \optionFlag{c}, but delimited with tab characters. The rightmost column is the ensemble free energy ($-\rt\log(Z_{k, l})$) in \kcalMol.}
    \end{itemize}
  \optionListItem{v}{Enables verbose output.}
\end{itemize}

\subsectionLabel{{\tt RNAmfpt}}{rnamfpt}

\subsubsection{Applications} \label{subsub:rnamfptapp}

\rnamfpt computes the mean first passage time (hitting time) of an user-provided input matrix, in CSV format. The user can provide as input either a 2D energy grid (such as those produced by \fft with the \optionFlag{c} format) or a transition probability matrix. The default expectation is a 2D energy grid composed of Boltzmann probabilities, though ensemble free energies are alternatively supported with \optionFlag{e}.

If providing a transition probability matrix $M$ as input (with the \optionFlag {t} flag), the format is still expected to be in CSV form, where columns $i$, $j$, $p$ represent the 0-indexed row-based probabilities for $M$, s.t. $M_{i, j} = p_{i\to j} = (i, j,p_{i\to j})$. Only non-zero $M_{i, j}$ entries are required.

We also provide an extension of \rnamfpt through \fftmfpt (\ref{sub:fftmfpt}) which leverages the 2D energy landscape output by \fft (\ref{sub:fft}) to estimate mean first passage time with good results.

\subsubsection{Example Usage} \label{subsub:rnamfptex}

These trivial examples make use of the file \ttt{./src/mfpt/example.csv}, which is the output of calling:

\begin{verbatim}
FFTbor2D -c -i GGGAAACCC -j '.........' -k '(((...)))' -e ./misc/rna_turner1999.par

0,3,+0.10531278
1,2,+0.00213850
1,4,+0.00509026
2,1,+0.28092942
2,3,+0.00032964
2,5,+0.15262286
3,0,+0.45357654
\end{verbatim}

\noindent A simple invocation of \rnamfpt appears like:

\begin{verbatim}
RNAmfpt -c ./src/mfpt/example.csv -xh

+699.65148561
\end{verbatim}

In the above example, the value output by \rnamfpt is the approximate hitting time for the 2D energy grid provided with the \optionFlag{c} flag. \rnamfpt converts this input to a transition probability matrix where only single base pair substitutions are valid (diagonal moves only using \optionFlag{x}), and the Hastings correction is applied with \optionFlag{h}.

\subsubsection{Options} \label{subsub:rnamfptopt}

\begin{itemize}
  \optionListItem{c}{\req Path to the input CSV file.}
  \item[Input format flags (mutually exclusive):] \hfill
    \begin{itemize}
      \item[] The default expectation is a 0-indexed 2D probability landscape in the CSV format described within \ref{subsub:rnamfptapp}. In this case, the transition probability is defined:
      \begin{equation}
        p_{a\to b} = \min(1, \exp(-(p_b / p_a) / \rt)) / N_a
      \end{equation}
      where $p_a$, $p_b$ are Boltzmann probabilities and $N_a$ is the number of neighbors of $a$.
      \optionListItem{e}{The input matrix is comprised of ensemble free energies rather than Boltzmann probabilities. If this flag is provided, the transition probability is defined:
      \begin{equation}
        p_{a\to b} = \min(1, \exp(-(E_b - E_a) / \rt)) / N_a
      \end{equation}
      where definitions follow as above.}
      \optionListItem{t}{The input CSV file is a transition probability matrix already, and \rnamfpt should not try to convert it into one. In this case, the first two columns in the CSV file are 0-indexed row-order indices into the transition probability matrix, and the third (final) column is the transition probability $p_{a\to b}$.}
    \end{itemize}
  \item[Transition probability matrix manipulation:] \hfill
    \begin{itemize}
      \optionListItem{x}{Only permit single base pair moves: $(i, j) \to (k, l) \implies (k, l) \in (i\pm 1, j\pm 1)$. This option assumes that the input is not already a transition probability matrix, the matrix is parameterized by base pair distance to some fixed, implicit \A, \B and that the matrix already satisfies the triangle inequality and parity condition.}
      \optionListItem{f}{The transition probability matrix generated by \rnamfpt should be fully connected.}
      \optionListItem{t}{The input CSV file is a transition probability matrix already, and \rnamfpt should not try to convert it into one. In this case, the first two columns in the CSV file are 0-indexed row-order indices into the transition probability matrix, and the third (final) column is the transition probability $p_{a\to b}$.}
      \optionListItem{h}{Enables the usage of the Hastings adjustment in formulating the transition probability matrix. Has no effect if the input is already a transition matrix (using \optionFlag{t}) or fully connected (using using \optionFlag{f}). When enabled, the transition probabilities are defined as:
      \begin{equation}
        p_{a\to b} = \min(1, (N_a / N_b) \times \exp(-(p_b / p_a) / \rt)) / N_a
      \end{equation}
      where variable definitions are the same as described above. Computation of $N_a$, $N_b$ respects grid boundaries and the triangle inequality, with base pair distance $d_{bp}(A,B)$ inferred from the input energy landscape by looking for a non-zero $(0, d_{bp}(A,B))$ or $(d_{bp}(A,B), 0)$ position. Also works with the \optionFlag{e} flag to use energies instead of probabilities.}
    \end{itemize}
  \item[Using $\epsilon$ to inflate the energy landscape:] \hfill
    \begin{itemize}
      \item[] In instances where no direct path exists from \A to \B in single base pair steps, or one would like to adjust the energy landscape such that all valid positions are accessible, we provide a number of flags to make an $\epsilon$ adjustment to the input 2D probability landscape. Valid positions are defined as:
      \begin{equation}
        V = \{ (i, j) \mid 0 \leq i, j \leq n \wedge i + j \geq d_{bp}(A, B) \wedge i + j \equiv d_{bp}(A, B) \;(\bmod\; 2) \}
      \end{equation}
      where $n$ is set with \optionFlag{n} and $d_{bp}(A, B)$ with \optionFlag{d} (if it can't be inferred). All probabilities $\{ p_{i, j} \mid (i, j) \in V \}$ are then $\epsilon$-adjusted such that $p^*_{i, j} = \frac{p_{i, j} + \frac{\epsilon}{\left\vert{V}\right\vert}}{1 + \epsilon}$.
      \optionListItem{d}{Flag to explicitly provide $d_{bp}(A,B)$, as defined in \optionFlag{h}. Only required when $d_{bp}(A,B)$ can't be inferred from the input probability matrix by identifying a non-zero $(0, d_{bp}(A,B))$ or $(d_{bp}(A,B), 0)$ position in the input.}
      \optionListItem{n}{Maximum base pair distance $n$ to use when including all accessible positions.}
      \optionListItem{o}{The {\em total} $\epsilon$ probability to add to the input probability grid before renormalization. The {\em per-position} contribution will be $\frac{\epsilon}{\left\vert{V}\right\vert}$, where definitions are as above.}
    \end{itemize}
  \item[Mean first passage time options:] \hfill
    \begin{itemize}
      \optionListItem{a}{The 0-indexed position of $(0, d_{bp}(A,B))$ in the input CSV file, representing the starting state for folding. If this flag is not provided, \rnamfpt will attempt to infer it by looking for a non-zero $(0, d_{bp}(A,B))$ position in the input and present an error to the user if it can't be found. If the input is already a transition matrix (using \optionFlag{t}), \optionFlag{a} should be the index of the row / column correspondent to the start state.}
      \optionListItem{z}{The 0-indexed position of $(d_{bp}(A,B), 0)$ in the input CSV file, representing the target state for folding. Expectations are identical as with \optionFlag{a}.}
      \optionListItem{r}{Compute a transition rate matrix rather than a probability matrix. The rate matrix $M$ is defined such that $q_{i,i} = -\sum\limits_{j\neq i}q_{i,j}$. This flag is provided so that \rnaeq and extensions involving rate matrices can use a unified codebase for their generation, and is not intended for typical calls to \rnamfpt.}
      \optionListItem{p}{Use the Moore-Penrose pseudoinverse to invert the transition probability matrix. This can be useful when an approximate solution is desired for input which produces a singular transition probability matrix.}
      \optionListItem{l}{Prints all mean first passage times $\{\text{mfpt}_{X\to B} \mid X \in V \wedge X \neq B\}$ where $V$ is the set of valid positions for the given input.}
    \end{itemize}
  \optionListItem{v}{Enables verbose output.}
\end{itemize}

\subsectionLabel{{\tt RNAeq}}{rnaeq}

\subsubsection{Applications} \label{subsub:rnaeqapp}

\rnaeq is a tool to compute the population occupancy and equilibrium time for an RNA sequence, transitioning from a starting distribution wholly occupied by an arbitrary input structure \A (the empty structure by default). From this starting distribution, occupancy curves can be generated for any arbitrary structure \B, which is taken to be the MFE by default. The resulting population occupancy curves can be used to estimate the equilibrium time as well using a sliding window approach.

By default, this code takes an input RNA sequence \s and uses \ttt{RNAsubopt} from the Vienna package to generate all secondary structures for \s, making its use practical only for trivially small sequences. Alternatively an energy band can be enabled to only sample structures within $\Delta$ \kcalMol of the MFE structure using \optionFlag{c}. Even then, it is quite possible that exponential number of secondary structures makes a sampling-based approach intractable for anything but small RNAs, highlighting the difficulty of performing computational kinetics. In this case it's recommended to use a notion of macrostates, whereby the granularity of the transition space is decreased to make software more performant, at the expense of accuracy. The extension program \ffteq (\ref{sub:ffteq}) uses the 2D energy landscape from \fft (\ref{sub:fft}) to good effect, and more generally \rateeq (\ref{sub:rateeq}) allows the user to input an arbitrary rate matrix to perform population kinetics on, allowing for a user-defined generalization of macrostates.

\subsubsection{Example Usage} \label{subsub:rnaeqex}

\noindent A simple invocation of \rnaeq appears like:

\begin{verbatim}
RNAeq -o -s GGGAAACCC -l '(((...)))' -p 0.25

-3.250000	+0.00056212	+0.99856051
-3.000000	+0.00099929	+0.99744193
-2.750000	+0.00177604	+0.99545654
-2.500000	+0.00315519	+0.99193786
-2.250000	+0.00560102	+0.98571804
-2.000000	+0.00992932	+0.97477461
-1.750000	+0.01756010	+0.95567878
-1.500000	+0.03092313	+0.92284200
-1.250000	+0.05404704	+0.86782054
-1.000000	+0.09322305	+0.77973465
-0.750000	+0.15714791	+0.64949189
-0.500000	+0.25475008	+0.48144406
-0.250000	+0.38729984	+0.30830977
+0.000000	+0.53394003	+0.18159969
+0.250000	+0.64774409	+0.12138539
+0.500000	+0.69618181	+0.10316965
+0.750000	+0.70383144	+0.10055275
\end{verbatim}

Invoking \rnaeq in this fashion produces output in three columns representing
\begin{inparaenum}
  [\itshape a\upshape)]
  \item \logt, where $t$ is arbitrary time
  \item $p(B, \logt)$, the population occupancy of \B (defaulting to the MFE) at time \logt, and
  \item $p(A, \logt)$, the population occupancy of \A (defaulting to the empty structure) at time \logt.
\end{inparaenum}
The \optionFlag{o} flag indicates that we will permit \ttt{RNAsubopt} to sample structures having lonely base pairs, and \optionFlag{p} indicates that we would like \logt to increment in steps of 0.25. As before, all available options are described in detail below.

\subsubsection{Options} \label{subsub:rnaeqopt}

\begin{itemize}
  \optionListItem{g}{\rnaeq will only produce the eigenvalues for the rate matrix, rather than produce population occupancy values or equilibrium times. The is much faster because the eigenvector matrix does not need to be inverted.}
  \optionListItem{a}{Indicates the 0-indexed position in the rate matrix corresponding to the structure $S$ for which $p(S, t_0) = 1$. By default this is taken from \optionFlag{k}, but this flag is of use in extensions where precomputed rate matrices are provided as command-line input.}
  \optionListItem{z}{Indicates the 0-indexed position in the rate matrix corresponding to the target structure $S$ for which population occupancy curves should be computed or equilibrium times estimated. By default this is taken from \optionFlag{l}, but this flag is of use in extensions where precomputed rate matrices are provided as command-line input.}
  \optionListItem{r}{Serialization direction, can be one of -1, 1. When 1, the eigensystem and its inversion will be serialized using \ttt{TPL} to the binary file specified named by \optionFlag{f}. When -1, the file named by \optionFlag{f} will be loaded and used as the eigensystem of interest for the invocation of \rnaeq. This allows repeated analysis of the kinetic characteristics of a given rate matrix without redundant computation of the eigendecomposition.}
  \optionListItem{f}{The filename for the binary serialization of the eigensystem described by \optionFlag{r}. Depending on the value of \optionFlag{r}, either specifies a filename to read from (when \optionFlag{r} is -1) or write to (when \optionFlag{r} is 1).}
  \item[Input format flags:] \hfill
    \begin{itemize}
      \optionListItem{s}{\req The RNA sequence \s to be used by \rnaeq.}
      \optionListItem{k}{The starting structure for \rnaeq refolding. Represents the structure $S$ for which $p(S, t_0) = 1$. If not explicitly provided, the empty structure is used.}
      \optionListItem{l}{The target structure to be used by \rnaeq when computing population occupancy curves or equilibrium time. If not explicitly provided, the MFE structure is computed using \ttt{RNAfold} and used.}
      \optionListItem{c}{The \ttt{RNAsubopt} sampling threshold $\Delta$ (in \kcalMol) such that only suboptimal structures with energy less than $E_{MFE} + \Delta$ are generated. If not provided, all suboptimal structures are generated.}
      \optionListItem{o}{Allow \ttt{RNAsubopt} to sample structures containing lonely base pairs.}
    \end{itemize}
  \item[Managing the population occupancy time window:] \hfill
    \begin{itemize}
      \item[] As described in \ref{subsub:rnaeqex}, all time values presented by \rnaeq are in \logtime, so a time point of $10^6$ would be presented in the output as 6. This format is maintained across all of \rnaeq, and thus any flags dealing with time accept values in \logtime, similar to how the output times for population occupancy and equilibrium are in \logtime.
      \item[] By default, \rnaeq requires no configuration to reasonably estimate the time range of interest for arbitrary population curves. This is done by using what we refer to as a {\em soft bounding} heuristic. Due to our observed numeric instability when working with floating point numbers beyond \logtime $(-12, 12)$, \rnaeq sets two global time-points, $t_{0} \approx -10$ (\optionFlag{i}) and $t_{\inf} \approx 10$ (\optionFlag{j}). It is unreasonable to expect that the time range $[t_{0}, t_{\inf}]$ to always be of interest to the investigator, regardless of input sequence. On the contrary, there are many cases where an RNA rapidly reaches equilibrium, and large regions to the left (resp. right) of the sigmoidal curve have a $\frac{dp}{dt} \approx 0$, perhaps due to insufficient time to start refolding (resp. equilibrium having been achieved).
      \item[] \rnaeq prunes out these regions by identifying two positions, a \tStart value for which $\lvert p(t_{0}) - \tStart\rvert \approx \delta$, and corresponding \tStop for which $\lvert p(t_{\inf}) - \tStop\rvert \approx \delta$. In both instances, $\delta$ is taken to be $10^{-3}$ by default. In our experience, the time range $[\tStart, \tStop]$ is an effective {\em soft bound} for the population occupancy curve which helps to present only the window of interest to the investigator. If desired, it is possible to disable the soft bounding feature using \optionFlag{n}, which will present the entire timespan $[t_{0}, t_{\inf}]$ to the user, where $t_{0}$ can be set in \logtime with \optionFlag{i} (default -10), and $t_{\inf}$ can be set in \logtime with \optionFlag{j} (default 10).
      \optionListItem{i}{The \logtime to represent $t_0$, -10 by default. Serves as a hard bound to prevent numeric instability, values $\leq -12$ are not recommended.}
      \optionListItem{j}{The \logtime to represent $t_{\inf}$, 10 by default. Serves as a hard bound to prevent numeric instability, values $\geq 12$ are not recommended.}
      \optionListItem{p}{The step size $i$ to use when computing population occupancy curves. Population occupancy is computed at discrete times $(t_0, t_0 + i, t_0 + 2i, \cdots, t_{\inf} - i, t_{\inf})$.}
      \optionListItem{d}{$\delta$ value used to estimate {\em soft bounds} \tStart and \tStop for the computed population kinetics. Defaults to $10^{-3}$.}
      \optionListItem{n}{Disables the usage of soft bounds (estimated with \optionFlag{d}). The full time range $[t_{0}, t_{\inf}]$ (\optionFlag{i} to \optionFlag{j}) is output.}
    \end{itemize}
  \item[Equilibrium computation:] \hfill
    \begin{itemize}
      \item[] \rnaeq allows for the estimation of equilibrium time from an implicitly computed population occupancy curve for a target structure (\optionFlag{l}), refolding from a starting structure (\optionFlag{k}). The equilibrium time is estimated using a sliding window approach, starting from the {\em right soft bound} \tStop (see documentation above for definition). The sliding window (default size: 5, starting at \tStop) is used in the following fashion.
      \item[] If the probabilities at {\em all} positions $(i + 1, i + 2, \cdots, i + \text{\ttt{window\_size}} - 1)$ are within $\epsilon$ of $p(i)$, the window starting at $i$ is said to be in equilibrium (we will call this {\em satisfying the equilibrium condition}), and moved to the left. This process is continued until a window starting at some $j$ is found that is not at equilibrium, in which case $j + 1$, the last time the window equilibrium was satisfied, is returned. Should the window starting at \tStop not be in equilibrium already, the window is instead moved to the right until a position $j$ is encountered for which the equilibrium condition is satisfied, and returned. Should the sliding window ever encounter the hard bound $t_0$ (resp. $t_{\inf}$), the equilibrium time is said to be $-\infty$ (resp. $\infty$).
      \optionListItem{q}{Compute the estimated equilibrium time for the refolding of input sequence \s from \A to \B.}
      \optionListItem{h}{Equilibrium is considered for all macrostates, rather than just the refolding of \A to \B. A window starting at index $i$ is then said to be in equilibrium if the population occupancy curves for all macrostates $M^*$ s.t. $M^* = M - \{A\}$ are in equilibrium at $i$.}
      \optionListItem{e}{The maximum deviation $\epsilon$ that all window indexes may have with the left-most position while still being considered {\em in equilibrium}. Defaults to $10^{-4}$.}
      \optionListItem{w}{The window size used for predicting equilibrium. Equilibrium is considered as having been achieved when all indexes $(i + 1, i + 2, \cdots, i + \text{\ttt{window\_size}} - 1)$ have values within $\epsilon$ (\optionFlag{e}) of the population proportion at index $i$.}
    \end{itemize}
  \optionListItem{t}{The temperature at which structures as sampled via \ttt{RNAsubopt}. The default is $37^{\circ}$C.}
  \optionListItem{b}{Enables the output of performance related benchmarking for all major subroutines in \rnaeq.}
  \optionListItem{v}{Enables verbose output.}
\end{itemize}

\sectionLabel{Extensions}{extprogs}

\subsectionLabel{{\tt FFTmfpt}}{fftmfpt}

\subsubsection{Applications} \label{subsub:fftmfptapp}

\fftmfpt can be used to estimate the mean first passage time of a given RNA in the same fashion as \rnamfpt, but using the 2D energy landscape computed by \fft as the underlying graph for the Markov chain. We expect this extension to be particularly useful to investigators interested in leveraging the speed of \fft as a coarse-grained representation of the refolding landscape in order to quickly estimate hitting times for a large collection of sequences, where speed is a major factor.

\fftmfpt uses the \multiParam framework to accept all command line flags available for \fft (prefixed by \ttt{--fftbor2d-}) and \rnamfpt (prefixed by \ttt{--mfpt-}). The only required flags are \ttt{--fftbor2d-i} (input sequence \s), \ttt{--fftbor2d-j} (starting structure \A), \ttt{--fftbor2d-k} (target structure \B), and a move type for the Markov chain, one of \ttt{--mfpt-x} or \ttt{--mfpt-f}.
See the command-line options documentation for \fft (\ref{subsub:fftboropt}) and \rnamfpt (\ref{subsub:rnamfptopt}) for a full description of all available settings.

\subsubsection{Example Usage} \label{subsub:fftmfptex}

In the following example, we compute the estimated hitting time of a toy 9 nt. sequence permitting only single base pair moves and applying the Hastings adjustment to the transition probability matrix.

\begin{verbatim}
FFTmfpt --fftbor2d-i GGGAAACCC --fftbor2d-j "........." --fftbor2d-k "(((...)))" \
--mfpt-x --mfpt-h

6786.738209
\end{verbatim}

To highlight the speed of computing kinetics in this fashion, consider the following 76 nt. tRNA sequence for which the mean first passage time is estimated in approximately one second of wall time on a laptop!

\begin{verbatim}
time FFTmfpt --mfpt-x --mfpt-h \
--fftbor2d-i \
'GCCUCCUUAGCGCAGUAGGUAGCGCGUCAGUCUCAUAAUCUGAAGGUCCUGAGUUCGAACCUCAGAGGGGGCACCA' \
--fftbor2d-j \
'............................................................................' \
--fftbor2d-k \
'(((((((..((((........)))).((((.........)))).....(((((.......))))))))))))....'

4509.578593

real	0m1.146s
user	0m3.743s
sys	0m0.039s
\end{verbatim}

\subsectionLabel{{\tt FFTeq}}{ffteq}

\subsubsection{Applications} \label{subsub:ffteqapp}

The intention of \ffteq is to present an efficient estimator of population occupancy and equilibrium time for a given RNA sequence in a similar fashion to \fftmfpt (\ref{subsub:fftmfptapp}), making use of the energy grid computed by \fft as a coarse grained graph for the Markov process. As with \fftmfpt (\ref{subsub:fftmfptapp}), the only required flags are \ttt{--fftbor2d-i} (input sequence \s), \ttt{--fftbor2d-j} (starting structure \A), and \ttt{--fftbor2d-k} (target structure \B).

\fftmfpt uses the \multiParam framework to accept all command line flags available for \fft (prefixed by \ttt{--fftbor2d-}), \rnamfpt (prefixed by \ttt{--mfpt-}), and \rnaeq (prefixed by \ttt{--population-}).

\subsubsection{Example Usage} \label{subsub:ffteqex}

\ffteq can be used to generate population occupancy curves in the following manner:

\begin{verbatim}
FFTeq --fftbor2d-i GGGAAACCC --fftbor2d-j "........." --fftbor2d-k "(((...)))" \
--population-p 0.5

-1.500000	+0.00000001	+0.99937772
-1.000000	+0.00000029	+0.99809540
-0.500000	+0.00000753	+0.99449426
+0.000000	+0.00014023	+0.98557561
+0.500000	+0.00145114	+0.96352653
+1.000000	+0.00733188	+0.90182966
+1.500000	+0.02430557	+0.74360243
+2.000000	+0.06459245	+0.47569262
+2.500000	+0.14819884	+0.31072886
+3.000000	+0.33391730	+0.23696313
+3.500000	+0.60157943	+0.13826409
+4.000000	+0.70229737	+0.10112492
\end{verbatim}

It can also estimate equilibrium time, just as \rnaeq can:

\begin{verbatim}
FFTeq --fftbor2d-i GGGAAACCC --fftbor2d-j "........." --fftbor2d-k "(((...)))" \
--population-q

3.995000
\end{verbatim}

To highlight the speed of \ffteq, consider the following real-world example, using the same tRNA as in the \fftmfpt (\ref{subsub:fftmfptex}). The equilibrium time is estimated from the population occupancy curve in approximately 10 seconds on a laptop!

\begin{verbatim}
time FFTeq --population-q \
--fftbor2d-i \
'GCCUCCUUAGCGCAGUAGGUAGCGCGUCAGUCUCAUAAUCUGAAGGUCCUGAGUUCGAACCUCAGAGGGGGCACCA' \
--fftbor2d-j \
'............................................................................' \
--fftbor2d-k \
'(((((((..((((........)))).((((.........)))).....(((((.......))))))))))))....'

3.111000

real	0m10.550s
user	0m13.258s
sys	0m0.067s
\end{verbatim}

\subsectionLabel{{\tt RateEq}}{rateeq}

\subsubsection{Applications} \label{subsub:rateeqapp}

The program \rateeq allows an investigator to compute population occupancy curves and equilibrium times using the underlying functions in \rnaeq, but providing their own transition rate matrix. This allows users to easily use the Hermes framework for kinetics applications beyond its current scope, and allows for arbitrary generalizations of macrostates or exhaustive kinetics through a single tool, similar to the generality of \rnamfpt.

\rateeq accepts command-line options for both \rnamfpt (using \ttt{--mfpt-}) and \rnaeq (using \ttt{--population-}), where \rnamfpt functions are used to convert the rate matrix (provided via CSV with the \ttt{--mfpt-c} flag) to a generalized data structure, and \rnaeq performs the required eigendecomposition. The only required flags are \ttt{--mfpt-c} to provide the input rate matrix, in the CSV format described in \ref{subsub:rnamfptapp}, and \ttt{--population-a} (resp. \ttt{--population-z}) to indicate the 0-indexed position in the rate matrix correspondent to the starting state (resp. ending state), described in greater detail in \ref{subsub:rnaeqopt}.

\subsubsection{Example Usage} \label{subsub:rateeqex}

These trivial examples make use of the following CSV file.

\begin{verbatim}
./ext/population_from_rate_matrix/all_structures_for_gggaaaccc\
__19_5_rate_move_with_hastings.csv
\end{verbatim}

This file is the rate matrix derived from all compatible structures for the toy sequence \ttt{GGGAAACCC}, similar to the matrix computed by \rnaeq when invoked like \ttt{RNAeq -s GGGAAACCC -o}. The index representing the empty structure (starting state) is 19 and the MFE structure is located at index 5.

\begin{verbatim}
RateEq --population-a 19 --population-z 5 --population-p 0.5 --mfpt-c \
./ext/population_from_rate_matrix/all_structures_for_gggaaaccc\
__19_5_rate_move_without_hastings.csv

-2.000000	+0.00000000	+0.99878366
-1.500000	+0.00000014	+0.99619920
-1.000000	+0.00000415	+0.98841027
-0.500000	+0.00010582	+0.96692649
+0.000000	+0.00184091	+0.91694937
+0.500000	+0.01529280	+0.80912513
+1.000000	+0.05796537	+0.57473609
+1.500000	+0.13220381	+0.27178670
+2.000000	+0.23416181	+0.16602654
+2.500000	+0.41551053	+0.12445470
+3.000000	+0.57547984	+0.08935250
+3.500000	+0.59543269	+0.08497569
\end{verbatim}

The above example computes the population occupancy curves for the given rate matrix (in \logtime increments of 0.5, specified by the \ttt{--population-p 0.5} flag), while the invocation below estimates the equilibrium time for state 5 (representing the MFE structure), starting from state 19 (representing the empty structure).

\begin{verbatim}
RateEq --population-a 19 --population-z 5 --population-q --mfpt-c \
./ext/population_from_rate_matrix/all_structures_for_gggaaaccc\
__19_5_rate_move_without_hastings.csv

3.235000
\end{verbatim}

\clearpage

\sectionLabel{References}{refs}

\renewcommand{\refname}{\vskip -1cm}
\bibliographystyle{plain}
\bibliography{references}

\end{document}
